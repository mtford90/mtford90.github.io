---
layout: post
title:  "Introducing Silk, live profiling for Django"
date:   2014-06-14 14:44:00
categories: python django
summary: "Introducing Silk, a live profiling and inspection tool for the Django framework."
permalink: /blog/2/
---

Silk is a live profiling and inspection tool for the Django framework. It:

* Intercepts requests and responses, recording:
    * SQL Queries
    * Response times
    * Headers
    * Bodies
* Allows tracing of SQL queries via Python stack traces
* Profiles blocks of code and functions 
* Generates code and commands for replaying requests

A [live demo](/silk) is actively profiling this site. The
github readme is currently acting as documentation and is available [here](https://github.com/mtford90/silk).

Silk releases can be downloaded from [here](https://github.com/mtford90/silk/releases) or installed via pip into your virtualenv:

```
pip install django-silk
```

Below is a feature summary:

## Request Inspection

The Silk middleware intercepts and stores requests and responses and stores them in the configured database.
These requests can then be filtered and inspected using Silk's UI through the request overview:

<img src="https://raw.githubusercontent.com/mtford90/silk/master/screenshots/1.png" width="720px"/>

Further details on each request are also available by clicking the relevant request:

<img src="https://raw.githubusercontent.com/mtford90/silk/master/screenshots/2.png" width="720px"/>

## SQL Inspection

Silk also intercepts SQL queries that are generated by each request. We can get a summary on things like 
the tables involved, number of joins and execution time:

<img src="https://raw.githubusercontent.com/mtford90/silk/master/screenshots/3.png" width="720px"/>

Before diving into the stack trace to figure out where this request is coming from:

<img src="https://raw.githubusercontent.com/mtford90/silk/master/screenshots/5.png" width="720px"/>

## Profiling

Silk can also be used to profile random blocks of code/functions. It provides a decorator and a context
manager for this purpose. 

For example:

```
@silk_profile(name='View Blog Post')
def post(request, post_id):
    p = Post.objects.get(pk=post_id)
    return render_to_response('post.html', {
        'post': p
    })
```

Whenever a blog post is viewed we get an entry within the Silk UI:

<img src="https://raw.githubusercontent.com/mtford90/silk/master/screenshots/7.png" width="720px"/>

Silk profiling not only provides execution time, but also collects SQL queries executed within the block in the same fashion as with requests:

<img src="https://raw.githubusercontent.com/mtford90/silk/master/screenshots/8.png" width="720px"/>

Note that currently profiling does not occur outside of the request/response cycle.

## Experimental Features

The below features are still in need of thorough testing and should be considered experimental.

### Dynamic Profiling

One of Silk's more interesting features is dynamic profiling. If for example we wanted to profile a function in a dependency to which we only have read-only access (e.g. system python libraries owned by root) we can add the following to `settings.py` to apply a decorator at runtime:

```
SILKY_DYNAMIC_PROFILING = [{
    'module': 'path.to.module',
    'function': 'MyClass.bar'
}]
```

which is roughly equivalent to:

```
class MyClass(object):
    @silk_profile()
    def bar(self):
        pass
```

### Code Generation

Silk currently generates two bits of code per request:

<img src="https://raw.githubusercontent.com/mtford90/silk/master/screenshots/9.png" width="720px"/>

Both are intended for use in replaying the request. The curl command can be used to replay via command-line and the python code can be used within a Django unit test or simply as a standalone script.